package org.helper.jdbctracer;

import java.sql.*;
import java.util.logging.Level;

class TraceStatement<T extends Statement> implements Statement {
    final T wrapped;
    final Output output;
    final private TraceConnection connection;

    TraceStatement(T toWrap, TraceConnection c) {
        wrapped = toWrap;
        output = c.output;
        connection = c;
    }

    ResultSet wrap(ResultSet rs) {
        return output.enabled(Level.FINEST) ? new TraceResultSet(rs,this) : rs;
    }

    public ResultSet executeQuery(String sql) throws SQLException {
        return output.act(Level.INFO, sql, () -> wrap(wrapped.executeQuery(sql)));
    }

    public int executeUpdate(String sql) throws SQLException {
        return output.act(Level.INFO, sql, () -> wrapped.executeUpdate(sql));
    }

    public boolean execute(String sql) throws SQLException {
        return output.act(Level.INFO, sql, () -> wrapped.execute(sql));
    }

    public void close() throws SQLException {
        output.act(Level.FINE, "CLOSE STMT", wrapped::close, null);
    }

    public int getMaxFieldSize() throws SQLException {
        return output.act(Level.FINEST, "GET MAXFIELDSIZE", wrapped::getMaxFieldSize);
    }

    public void setMaxFieldSize(int max) throws SQLException {
        output.act(Level.FINER, "SET MAXFIELDSIZE", () -> wrapped.setMaxFieldSize(max), max);
    }

    public int getMaxRows() throws SQLException {
        return output.act(Level.FINER, "GET MAXROWS", wrapped::getMaxRows);
    }

    public void setMaxRows(int max) throws SQLException {
        output.act(Level.FINE, "SET MAXROWS", () -> wrapped.setMaxRows(max), max);
    }

    public int getQueryTimeout() throws SQLException {
        return output.act(Level.FINER, "GET QUERYTIMEOUT", wrapped::getQueryTimeout);
    }

    public void setQueryTimeout(int seconds) throws SQLException {
        output.act(Level.FINE, "SET QUERYTIMEOUT", () -> wrapped.setQueryTimeout(seconds), seconds);
    }

    public void setEscapeProcessing(boolean enable) throws SQLException {
        output.act(Level.FINER, "SET ESCAPEPROCESSING", () -> wrapped.setEscapeProcessing(enable), enable);
    }

    public void cancel() throws SQLException {
        output.act(Level.INFO, "CANCEL", wrapped::cancel, null);
    }

    public SQLWarning getWarnings() throws SQLException {
        return wrapped.getWarnings();
    }

    public void clearWarnings() throws SQLException {
        wrapped.clearWarnings();
    }

    public void setCursorName(String name) throws SQLException {
        output.act(Level.FINE, "SET CURSORNAME", () -> wrapped.setCursorName(name), name);
    }

    public ResultSet getResultSet() throws SQLException {
        return output.act(Level.FINER, "GET RESULTSET", () -> wrap(wrapped.getResultSet()));
    }

    public int getUpdateCount() throws SQLException {
        return output.act(Level.FINER, "GET UPDATECOUNT", wrapped::getUpdateCount);
    }

    public boolean getMoreResults() throws SQLException {
        return wrapped.getMoreResults();
    }

    public void setFetchDirection(int direction) throws SQLException {
        wrapped.setFetchDirection(direction);
    }

    public int getFetchDirection() throws SQLException {
        return wrapped.getFetchDirection();
    }

    public void setFetchSize(int rows) throws SQLException {
        output.act(Level.FINE, "SET FETCHSIZE", () -> wrapped.setFetchSize(rows), rows);
    }

    public int getFetchSize() throws SQLException {
        return output.act(Level.FINER, "GET FETCHSIZE", wrapped::getFetchSize);
    }

    public int getResultSetConcurrency() throws SQLException {
        return wrapped.getResultSetConcurrency();
    }

    public int getResultSetType() throws SQLException {
        return wrapped.getResultSetType();
    }

    public void addBatch(String sql) throws SQLException {
        output.act(Level.INFO, "ADDBATCH", () -> wrapped.addBatch(sql), sql);
    }

    public void clearBatch() throws SQLException {
        output.act(Level.FINE, "CLEARBATCH", wrapped::clearBatch, null);
    }

    public int[] executeBatch() throws SQLException {
        return output.act(Level.INFO, "EXECUTEBATCH", wrapped::executeBatch);
    }

    public Connection getConnection() {
        return connection;
    }

    public boolean getMoreResults(int current) throws SQLException {
        return wrapped.getMoreResults(current);
    }

    public ResultSet getGeneratedKeys() throws SQLException {
        return wrap(wrapped.getGeneratedKeys());
    }

    public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
        return output.act(Level.INFO, sql, () -> executeUpdate(sql, autoGeneratedKeys));
    }

    public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
        return output.act(Level.INFO, sql, () -> executeUpdate(sql, columnIndexes));
    }

    public int executeUpdate(String sql, String[] columnNames) throws SQLException {
        return output.act(Level.INFO, sql, () -> executeUpdate(sql, columnNames));
    }

    public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
        return output.act(Level.INFO, sql, () -> execute(sql, autoGeneratedKeys));
    }

    public boolean execute(String sql, int[] columnIndexes) throws SQLException {
        return output.act(Level.INFO, sql, () -> execute(sql, columnIndexes));
    }

    public boolean execute(String sql, String[] columnNames) throws SQLException {
        return output.act(Level.INFO, sql, () -> execute(sql, columnNames));
    }

    public int getResultSetHoldability() throws SQLException {
        return wrapped.getResultSetHoldability();
    }

    public boolean isClosed() throws SQLException {
        return wrapped.isClosed();
    }

    public void setPoolable(boolean poolable) throws SQLException {
        output.act(Level.FINE, "SET POOLABLE", () -> wrapped.setPoolable(poolable), poolable);
    }

    public boolean isPoolable() throws SQLException {
        return output.act(Level.FINER, "ISPOOLABLE", wrapped::isPoolable);
    }

    public void closeOnCompletion() throws SQLException {
        wrapped.closeOnCompletion();
    }

    public boolean isCloseOnCompletion() throws SQLException {
        return wrapped.isCloseOnCompletion();
    }

    public <Q> Q unwrap(Class<Q> iface) throws SQLException {
        return wrapped.unwrap(iface);
    }

    public boolean isWrapperFor(Class<?> iface) throws SQLException {
        return wrapped.isWrapperFor(iface);
    }
}
